<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Audience Vector Library: Audience Vector Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Audience Vector Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Audience Vector Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Audience Vector Library (AVL) is a cross-platform C++ library for floating-point arithmetic. The supported target platforms are Generic C++, DeltaMax, DMX1A, HemiDelta, HemiLite, and HMD1A. The supported compilers are <code>gcc</code>, <code>xt-xcc</code>, and MSVC. The native floating-point format is 32-bit IEEE single precision for the Generic target and 32-bit AFloat for the Audience targets.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Target  </th><th class="markdownTableHeadCenter">Native Format  </th><th class="markdownTableHeadLeft">Invocation   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Generic C++  </td><td class="markdownTableBodyCenter">IEEE Single Precision  </td><td class="markdownTableBodyLeft">#<code>define AVL_GENERIC</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">DeltaMax  </td><td class="markdownTableBodyCenter">32-bit AFloat  </td><td class="markdownTableBodyLeft">#<code>define AVL_DELTAMAX</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">DMX1A  </td><td class="markdownTableBodyCenter">32-bit AFloat  </td><td class="markdownTableBodyLeft">#<code>define AVL_DMX1A</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HemiDelta  </td><td class="markdownTableBodyCenter">32-bit AFloat  </td><td class="markdownTableBodyLeft">#<code>define AVL_HEMI</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">HemiLite  </td><td class="markdownTableBodyCenter">32-bit AFloat  </td><td class="markdownTableBodyLeft">#<code>define AVL_HEMI</code>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyLeft">HMD1A  </td><td class="markdownTableBodyCenter">32-bit AFloat  </td><td class="markdownTableBodyLeft">#<code>define AVL_HEMI</code>   </td></tr>
</table>
<p>Define the target before including the headers: </p><div class="fragment"><div class="line"><span class="preprocessor">#define AVL_GENERIC</span></div><div class="line"><span class="preprocessor">#include &quot;AVL.h&quot;</span></div></div><!-- fragment --><h3>The <a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a> Class</h3>
<p>The <code><a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a></code> class contains an abstract floating-point number in the native format. </p><div class="fragment"><div class="line"><a class="code" href="structAScalar.html">AScalar</a> x = 13;</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> y = 5.2;</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> z = 1 / 3.0;</div></div><!-- fragment --><p> Use the <code>CONST_ASCALAR</code> macro to avoid a runtime conversion from integer or IEEE floating-point constants or when the full 26-bits of AFloat precision is required. </p><div class="fragment"><div class="line"><a class="code" href="structAScalar.html">AScalar</a> x = <a class="code" href="AScalar_8h.html#ae6cbfa3faf4dc3f32be54ac33263de17">CONST_ASCALAR</a>(13);</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> y = <a class="code" href="AScalar_8h.html#ae6cbfa3faf4dc3f32be54ac33263de17">CONST_ASCALAR</a>(5.2);</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> z = <a class="code" href="AScalar_8h.html#ae6cbfa3faf4dc3f32be54ac33263de17">CONST_ASCALAR</a>(1 / 3.0);</div></div><!-- fragment --><p> Use the built-in constants when available. </p><div class="fragment"><div class="line"><a class="code" href="structAScalar.html">AScalar</a> pi  = <a class="code" href="structAScalar.html#ac87aacf25a3b268dd4fd1cded44e7660">AScalar::Pi</a>();</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> zip = <a class="code" href="structAScalar.html#a692c1b3b5f5cd1d8ae913a9ae79d2e07">AScalar::Zero</a>();</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> big = <a class="code" href="structAScalar.html#af503abd2840985e0354972c6f3d6a6e6">AScalar::MaxAFloat</a>();</div></div><!-- fragment --><h3>Arrays of Floating-Point Constants</h3>
<p>To avoid generating static initializers, arrays of <code><a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a></code> constants should be declared as <code>"uint32_t"</code> but accessed via an <code>"AScalar*"</code>.</p>
<p>Here's an example of an array of floating-point constants representing the whole numbers from 1.0 through 8.0 in AFloat format, and a loop to compute the sum of the numbers in the array: </p><div class="fragment"><div class="line"><span class="keyword">static</span> uint32_t afloat_array[8] = {</div><div class="line">    0x40000000, 0x42000000, 0x43000000, 0x44000000,</div><div class="line">    0x44800000, 0x45000000, 0x45800000, 0x46000000</div><div class="line">};</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a>* p_afloats = (<a class="code" href="structAScalar.html">AScalar</a>*) afloat_array;</div><div class="line"></div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> sum = <a class="code" href="structAScalar.html#a692c1b3b5f5cd1d8ae913a9ae79d2e07">AScalar::Zero</a>();</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div><div class="line">  sum += p_afloats[i];</div></div><!-- fragment --><p> Because these numbers are in AFloat format, a different sum will be computed on an IEEE format target.</p>
<p><code><a class="el" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee" title="Generate a compile-time integer in the native float format. ">RAW_LITERAL()</a></code> can be used to generate floating-point constants in native format so the above can be rewritten to produce the same result on AFloat or IEEE targets. </p><div class="fragment"><div class="line"><span class="keyword">static</span> uint32_t native_array[8] = {</div><div class="line">    <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(1.0), <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(2.0), <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(3.0), <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(4.0),</div><div class="line">    <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(5.0), <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(6.0), <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(7.0), <a class="code" href="AScalar_8h.html#a9957dcb0c0c0e04efa6b4268066c0aee">RAW_LITERAL</a>(8.0)</div><div class="line">};</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a>* p_natives = (<a class="code" href="structAScalar.html">AScalar</a>*) native_array;</div><div class="line"></div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> sum = <a class="code" href="structAScalar.html#a692c1b3b5f5cd1d8ae913a9ae79d2e07">AScalar::Zero</a>();</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)</div><div class="line">    sum += p_natives[i];</div></div><!-- fragment --><h3>Example: Sum of an Array</h3>
<p>This example computes the sum of an array of <code><a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a></code>s by adding them one at a time: </p><div class="fragment"><div class="line"><a class="code" href="structAScalar.html">AScalar</a> sum_v1(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <span class="keywordtype">int</span> n)</div><div class="line">{</div><div class="line">    <span class="comment">// 400 cycles on HemiDelta (for n = 100)</span></div><div class="line">    <span class="comment">// 400 cycles on DeltaMax  (for n = 100)</span></div><div class="line"></div><div class="line">    <a class="code" href="structAScalar.html">AScalar</a> sum = <a class="code" href="structAScalar.html#a692c1b3b5f5cd1d8ae913a9ae79d2e07">AScalar::Zero</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++)</div><div class="line">        sum += pDataIn[i];</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> sum;</div><div class="line">}</div></div><!-- fragment --><p> The cycle counts above (and below) are asymptotic counts of cycles spent in the loop and ignore overhead. HemiDelta cycle counts also apply to HemiLite and HMD1A.</p>
<h3>The <a class="el" href="structAScalarArray.html" title="Wraps an abstract pointer to an AScalar and a length. ">AScalarArray</a> Class</h3>
<p>The <code><a class="el" href="structAScalarArray.html" title="Wraps an abstract pointer to an AScalar and a length. ">AScalarArray</a></code> class is an abstract array of <code><a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a></code>s encapsulating a pointer and a size. <code><a class="el" href="structAScalarArray.html" title="Wraps an abstract pointer to an AScalar and a length. ">AScalarArray</a></code> provides a number of optimized operations on arrays including sum: </p><div class="fragment"><div class="line"><a class="code" href="structAScalar.html">AScalar</a> sum_v2(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <span class="keywordtype">int</span> n)</div><div class="line">{</div><div class="line">    <span class="comment">// 100 cycles on HemiDelta (for n = 100)</span></div><div class="line">    <span class="comment">//  50 cycles on DeltaMax  (for n = 100)</span></div><div class="line"></div><div class="line">    <a class="code" href="structAScalarArray.html">AScalarArray</a> array(n, pDataIn);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> array.sum();</div><div class="line">}</div></div><!-- fragment --><h3>Example: Square Root</h3>
<p>This example computes the square root of an array of 100 <code><a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a></code>s: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> sqrt_v1(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 600 cycles on HemiDelta</span></div><div class="line">    <span class="comment">// 600 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; i++) {</div><div class="line">       <a class="code" href="structAScalar.html">AScalar</a> src = pDataIn[i];</div><div class="line">        pDataOut[i] = src * src.<a class="code" href="structAScalar.html#ac70d406e8d72542fd9f9d435b39465f9">f_invsqrt</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>The <a class="el" href="structAQuad.html" title="Wrapper for a vr128, two vr64s, or float[4]. ">AQuad</a> Class</h3>
<p>The <code><a class="el" href="structAQuad.html" title="Wrapper for a vr128, two vr64s, or float[4]. ">AQuad</a></code> class is a vector of four <code><a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a></code>s and can be used to vectorize a loop. This version of the square root loop requires the input and output to be 16-byte aligned on DeltaMax or DMX1A and 8-byte aligned on Hemi targets: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> sqrt_v2(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 225 cycles on HemiDelta</span></div><div class="line">    <span class="comment">// 225 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a>* pQuadIn  = (<a class="code" href="structAQuad.html">AQuad</a>*) pDataIn;</div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a>* pQuadOut = (<a class="code" href="structAQuad.html">AQuad</a>*) pDataOut;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 25; i++) {</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> src = pQuadIn[i];</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> dst;</div><div class="line"></div><div class="line">        dst.<a class="code" href="structAQuad.html#a749b1f36f2a4cef5f71f2f43d3d61ffc">set_q0</a>(src.<a class="code" href="structAQuad.html#a41b59b9e3f7bd033bdd8fcad71d6dabf">q0</a>().<a class="code" href="structAScalar.html#ac70d406e8d72542fd9f9d435b39465f9">f_invsqrt</a>());</div><div class="line">        dst.<a class="code" href="structAQuad.html#a667e56e549bed681e60f024cd0482c2d">set_q1</a>(src.<a class="code" href="structAQuad.html#afe68591438c2fc800014070f2902b856">q1</a>().<a class="code" href="structAScalar.html#ac70d406e8d72542fd9f9d435b39465f9">f_invsqrt</a>());</div><div class="line">        dst.<a class="code" href="structAQuad.html#a4391ae1f8c4f3639209ea3c5a4d8c146">set_q2</a>(src.<a class="code" href="structAQuad.html#a19fd1d20fe5f1419232bd2f1be13a7a0">q2</a>().<a class="code" href="structAScalar.html#ac70d406e8d72542fd9f9d435b39465f9">f_invsqrt</a>());</div><div class="line">        dst.<a class="code" href="structAQuad.html#ae16f7af9010672564c09b362a3e38ce0">set_q3</a>(src.<a class="code" href="structAQuad.html#aeeef3f8460388c514fbc504410b54cbc">q3</a>().<a class="code" href="structAScalar.html#ac70d406e8d72542fd9f9d435b39465f9">f_invsqrt</a>());</div><div class="line"></div><div class="line">        pQuadOut[i] = src * dst;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Example: Squared Absolute Value</h3>
<p>Consider a function <code>c_squabs()</code> that takes an input array of 50 complex numbers and outputs the squared absolute values of the inputs as an array of 50 scalars. Treating the complex inputs as consecutive <code><a class="el" href="structAScalar.html" title="Wrapper for an fr32 or a float. ">AScalar</a></code>s, the function could be written straightforwardly like so: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> c_squabs_v1(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 350 cycles on HemiDelta</span></div><div class="line">    <span class="comment">// 350 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; i++) {</div><div class="line">        <a class="code" href="structAScalar.html">AScalar</a> x = pDataIn[2 * i];</div><div class="line">        <a class="code" href="structAScalar.html">AScalar</a> y = pDataIn[2 * i + 1];</div><div class="line">        pDataOut[i] = x * x + y * y;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> It's a good idea to use fused multiply-add operations when possible: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> c_squabs_v2(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 300 cycles on HemiDelta</span></div><div class="line">    <span class="comment">// 250 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; i++) {</div><div class="line">        <a class="code" href="structAScalar.html">AScalar</a> x = pDataIn[2 * i];</div><div class="line">        <a class="code" href="structAScalar.html">AScalar</a> y = pDataIn[2 * i + 1];</div><div class="line">        pDataOut[i] = (x * x).mul_add(y, y);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>The <a class="el" href="structAComplex.html" title="Wrapper for a vr64, vr128, or std::complex&lt;float&gt; ">AComplex</a> Class</h3>
<p>The <code><a class="el" href="structAComplex.html" title="Wrapper for a vr64, vr128, or std::complex&lt;float&gt; ">AComplex</a></code> class contains a complex floating-point number in the native format. Assuming 8-byte alignment of the input, the <code>c_squabs()</code> function can be rewritten using <code><a class="el" href="structAComplex.html" title="Wrapper for a vr64, vr128, or std::complex&lt;float&gt; ">AComplex</a></code>: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> c_squabs_v3(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 200 cycles on HemiDelta</span></div><div class="line">    <span class="comment">// 250 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <a class="code" href="structAComplex.html">AComplex</a>* pComplexIn = (<a class="code" href="structAComplex.html">AComplex</a>*) pDataIn;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; i++) {</div><div class="line">        <a class="code" href="structAComplex.html">AComplex</a> c = pComplexIn[i];</div><div class="line">        pDataOut[i] = c.<a class="code" href="structAComplex.html#a7cc8a9764af07d4e50525aed46e204d7">norm_sq</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> The <code><a class="el" href="structAQuad.html" title="Wrapper for a vr128, two vr64s, or float[4]. ">AQuad</a></code> class can be used to process two complex numbers at a time. This version requires the input to be 16-byte aligned on DeltaMax or DMX1A and 8-byte aligned on Hemi targets: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> c_squabs_v4(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 150 cycles on HemiDelta</span></div><div class="line">    <span class="comment">// 175 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a>* pQuadIn = (<a class="code" href="structAQuad.html">AQuad</a>*) pDataIn;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 25; i++) {</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> q = pQuadIn[i];</div><div class="line">        pDataOut[2*i]     = q.<a class="code" href="structAQuad.html#aa868445c917108217412b8eb2de8befa">h0</a>().<a class="code" href="structAComplex.html#a7cc8a9764af07d4e50525aed46e204d7">norm_sq</a>();</div><div class="line">        pDataOut[2*i + 1] = q.<a class="code" href="structAQuad.html#ac0c45fe58f30e6b1ede38a8324628cb8">h1</a>().<a class="code" href="structAComplex.html#a7cc8a9764af07d4e50525aed46e204d7">norm_sq</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>Individual Function Optimization</h3>
<p>The cycle counts above assume the functions are compiled with <code>"-O2 -Os"</code>. On Xtensa targets, functions can be optimized individually. For example, space optimization can be turned off for a time-critical function: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef __XTENSA__</span></div><div class="line">    __attribute__((optimize (<span class="stringliteral">&quot;-O2&quot;</span>)))</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> c_squabs_v5(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 125 cycles on HemiDelta</span></div><div class="line">    <span class="comment">// 100 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a>*  pQuadIn    = (<a class="code" href="structAQuad.html">AQuad</a>*) pDataIn;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 25; i++) {</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> q = pQuadIn[i];</div><div class="line">        pDataOut[2*i]     = q.<a class="code" href="structAQuad.html#aa868445c917108217412b8eb2de8befa">h0</a>().<a class="code" href="structAComplex.html#a7cc8a9764af07d4e50525aed46e204d7">norm_sq</a>();</div><div class="line">        pDataOut[2*i + 1] = q.<a class="code" href="structAQuad.html#ac0c45fe58f30e6b1ede38a8324628cb8">h1</a>().<a class="code" href="structAComplex.html#a7cc8a9764af07d4e50525aed46e204d7">norm_sq</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3>The <a class="el" href="structAComplexArray.html" title="Wraps an abstract pointer to an AComplex and a length. ">AComplexArray</a> Class</h3>
<p>The <code>c_squabs()</code> function can also be written using the <code><a class="el" href="structAComplexArray.html" title="Wraps an abstract pointer to an AComplex and a length. ">AComplexArray</a></code> class which works similarly to the <code><a class="el" href="structAScalarArray.html" title="Wraps an abstract pointer to an AScalar and a length. ">AScalarArray</a></code> class: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> c_squabs_v6(<a class="code" href="structAScalar.html">AScalar</a>* pDataIn, <a class="code" href="structAScalar.html">AScalar</a>* pDataOut)</div><div class="line">{</div><div class="line">    <span class="comment">// 200 cycles on HemiDelta (125 cycles without -Os)</span></div><div class="line">    <span class="comment">// 100 cycles on DeltaMax</span></div><div class="line"></div><div class="line">    <a class="code" href="structAComplexArray.html">AComplexArray</a> c_array(50, (<a class="code" href="structAComplex.html">AComplex</a>*) pDataIn);</div><div class="line">    <a class="code" href="structAScalarArray.html">AScalarArray</a>  s_array(50, pDataOut);</div><div class="line"></div><div class="line">    s_array.norm_sq(c_array);</div><div class="line">}</div></div><!-- fragment --><h3>Example: Dot Products</h3>
<p>Consider a function that takes two arrays <code>X</code> and <code>Y</code> of length <code>N</code> and computes <code>X•X</code>, <code>Y•Y</code>, and <code>X•Y</code>. A straightforward implementation using <code><a class="el" href="structAScalarArray.html" title="Wraps an abstract pointer to an AScalar and a length. ">AScalarArray</a></code> is: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> dots_v1(<a class="code" href="structAScalar.html">AScalar</a>* x_in, <a class="code" href="structAScalar.html">AScalar</a>* y_in, <span class="keywordtype">int</span> n,</div><div class="line">             <a class="code" href="structAScalar.html">AScalar</a>&amp; xx_out, <a class="code" href="structAScalar.html">AScalar</a>&amp; yy_out, <a class="code" href="structAScalar.html">AScalar</a>&amp; xy_out)</div><div class="line">{</div><div class="line">    <span class="comment">// 600 cycles on HemiDelta for n == 100</span></div><div class="line">    <span class="comment">// 300 cycles on DeltaMax  for n == 100</span></div><div class="line"></div><div class="line">    <a class="code" href="structAScalarArray.html">AScalarArray</a> ax(n, x_in);</div><div class="line">    <a class="code" href="structAScalarArray.html">AScalarArray</a> ay(n, y_in);</div><div class="line"></div><div class="line">    xx_out = ax.dot(ax);</div><div class="line">    yy_out = ay.dot(ay);</div><div class="line">    xy_out = ax.dot(ay);</div><div class="line">}</div></div><!-- fragment --><p> Combining the calculations into a single loop and using <code><a class="el" href="structAQuad.html" title="Wrapper for a vr128, two vr64s, or float[4]. ">AQuad</a></code> gives better performance assuming N is a multiple of four: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> dots_v2(<a class="code" href="structAQuad.html">AQuad</a>* x_in, <a class="code" href="structAQuad.html">AQuad</a>* y_in, <span class="keywordtype">int</span> n,</div><div class="line">             <a class="code" href="structAScalar.html">AScalar</a>&amp; xx_out, <a class="code" href="structAScalar.html">AScalar</a>&amp; yy_out, <a class="code" href="structAScalar.html">AScalar</a>&amp; xy_out)</div><div class="line">{</div><div class="line">    <span class="comment">// 175 cycles on HemiDelta for n == 100</span></div><div class="line">    <span class="comment">// 100 cycles on DeltaMax  for n == 100</span></div><div class="line"></div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a> xx = <a class="code" href="structAQuad.html#ad512946f5960420d458bf6ef00964077">AQuad::Zero</a>();</div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a> yy = <a class="code" href="structAQuad.html#ad512946f5960420d458bf6ef00964077">AQuad::Zero</a>();</div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a> xy = <a class="code" href="structAQuad.html#ad512946f5960420d458bf6ef00964077">AQuad::Zero</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (n &gt;&gt; 2); i++) {</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> x = x_in[i];</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> y = y_in[i];</div><div class="line"></div><div class="line">        xx.<a class="code" href="structAQuad.html#a4ff8fb5bd87435e455dc081c7f344d3b">mul_acc</a>(x, x);</div><div class="line">        yy.<a class="code" href="structAQuad.html#a4ff8fb5bd87435e455dc081c7f344d3b">mul_acc</a>(y, y);</div><div class="line">        xy.<a class="code" href="structAQuad.html#a4ff8fb5bd87435e455dc081c7f344d3b">mul_acc</a>(x, y);</div><div class="line">    }</div><div class="line"></div><div class="line">    xx_out = xx.<a class="code" href="structAQuad.html#a870c1de9caf98b20058366ce892b4640">sum</a>();</div><div class="line">    yy_out = yy.<a class="code" href="structAQuad.html#a870c1de9caf98b20058366ce892b4640">sum</a>();</div><div class="line">    xy_out = xy.<a class="code" href="structAQuad.html#a870c1de9caf98b20058366ce892b4640">sum</a>();</div><div class="line">}</div></div><!-- fragment --><p> With space optimization turned off on Hemi targets, the compiler achieves the asymptotic performance of hand-coded intrinsics for this function: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef __XTENSA__</span></div><div class="line">    __attribute__((optimize (<span class="stringliteral">&quot;-O2&quot;</span>)))</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> dots_v3(<a class="code" href="structAQuad.html">AQuad</a>* x_in, <a class="code" href="structAQuad.html">AQuad</a>* y_in, <span class="keywordtype">int</span> n,</div><div class="line">             <a class="code" href="structAScalar.html">AScalar</a>&amp; xx_out, <a class="code" href="structAScalar.html">AScalar</a>&amp; yy_out, <a class="code" href="structAScalar.html">AScalar</a>&amp; xy_out)</div><div class="line">{</div><div class="line">    <span class="comment">// 150 cycles on HemiDelta for n == 100</span></div><div class="line">    <span class="comment">// 100 cycles on DeltaMax  for n == 100</span></div><div class="line"></div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a> xx = <a class="code" href="structAQuad.html#ad512946f5960420d458bf6ef00964077">AQuad::Zero</a>();</div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a> yy = <a class="code" href="structAQuad.html#ad512946f5960420d458bf6ef00964077">AQuad::Zero</a>();</div><div class="line">    <a class="code" href="structAQuad.html">AQuad</a> xy = <a class="code" href="structAQuad.html#ad512946f5960420d458bf6ef00964077">AQuad::Zero</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; (n &gt;&gt; 2); i++) {</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> x = x_in[i];</div><div class="line">        <a class="code" href="structAQuad.html">AQuad</a> y = y_in[i];</div><div class="line"></div><div class="line">        xx.<a class="code" href="structAQuad.html#a4ff8fb5bd87435e455dc081c7f344d3b">mul_acc</a>(x, x);</div><div class="line">        yy.<a class="code" href="structAQuad.html#a4ff8fb5bd87435e455dc081c7f344d3b">mul_acc</a>(y, y);</div><div class="line">        xy.<a class="code" href="structAQuad.html#a4ff8fb5bd87435e455dc081c7f344d3b">mul_acc</a>(x, y);</div><div class="line">    }</div><div class="line"></div><div class="line">    xx_out = xx.<a class="code" href="structAQuad.html#a870c1de9caf98b20058366ce892b4640">sum</a>();</div><div class="line">    yy_out = yy.<a class="code" href="structAQuad.html#a870c1de9caf98b20058366ce892b4640">sum</a>();</div><div class="line">    xy_out = xy.<a class="code" href="structAQuad.html#a870c1de9caf98b20058366ce892b4640">sum</a>();</div><div class="line">}</div></div><!-- fragment --><h3><a class="el" href="structAScalarMatrix.html" title="Wraps an abstract pointer to an AScalar and height and width. ">AScalarMatrix</a> and <a class="el" href="structAComplexMatrix.html" title="Wraps an abstract pointer to an AComplex and height and width. ">AComplexMatrix</a></h3>
<p>The <code><a class="el" href="structAScalarMatrix.html" title="Wraps an abstract pointer to an AScalar and height and width. ">AScalarMatrix</a></code> and <code><a class="el" href="structAComplexMatrix.html" title="Wraps an abstract pointer to an AComplex and height and width. ">AComplexMatrix</a></code> classes are two dimensional analogues to the array classes. This function computes the commutator of two 2x2 complex matrices: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> commutator2x2(<a class="code" href="structAComplexMatrix.html">AComplexMatrix</a>&amp; result, <span class="keyword">const</span> <a class="code" href="structAComplexMatrix.html">AComplexMatrix</a>&amp; a, <span class="keyword">const</span> <a class="code" href="structAComplexMatrix.html">AComplexMatrix</a>&amp; b)</div><div class="line">{</div><div class="line">    <a class="code" href="structAComplex.html">AComplex</a> buffer[2][4];</div><div class="line">    <a class="code" href="structAComplexMatrix.html">AComplexMatrix</a> tmp1(2, 2, buffer[0]);</div><div class="line">    <a class="code" href="structAComplexMatrix.html">AComplexMatrix</a> tmp2(2, 2, buffer[1]);</div><div class="line"></div><div class="line">    tmp1.mul(a, b);</div><div class="line">    tmp2.mul(b, a);</div><div class="line">    result.<a class="code" href="structAComplexMatrix.html#a20f2efd470c3719fab956e1888485b2e">sub</a>(tmp1, tmp2);   <span class="comment">// result = [a, b] = ab - ba</span></div><div class="line">}</div></div><!-- fragment --><p> The following code verifies some of the commutation relations between the Pauli spin matrices: </p><div class="fragment"><div class="line"><a class="code" href="structAComplex.html">AComplex</a> zero = <a class="code" href="structAComplex.html#a749ac35b9452523ceba7862d03c8fcca">AComplex::Zero</a>();</div><div class="line"><a class="code" href="structAComplex.html">AComplex</a> one  = <a class="code" href="structAComplex.html#a196a58c8a01e66b1b896143e3c61ae0a">AComplex::One</a>();</div><div class="line"><a class="code" href="structAComplex.html">AComplex</a> i    = <a class="code" href="structAComplex.html#a0368e8312784599f8be265a417a028df">AComplex::I</a>();</div><div class="line"><a class="code" href="structAScalar.html">AScalar</a> two   = <a class="code" href="structAScalar.html#a8f10fd985d66a27342d69f7a65c42e55">AScalar::Two</a>();</div><div class="line"></div><div class="line"><a class="code" href="structAComplex.html">AComplex</a> buffer[5][4];</div><div class="line"><a class="code" href="structAComplexMatrix.html">AComplexMatrix</a> Sx(2, 2, buffer[0]);</div><div class="line"><a class="code" href="structAComplexMatrix.html">AComplexMatrix</a> Sy(2, 2, buffer[1]);</div><div class="line"><a class="code" href="structAComplexMatrix.html">AComplexMatrix</a> Sz(2, 2, buffer[2]);</div><div class="line"></div><div class="line">Sx[0][0] = zero; Sx[0][1] = one;</div><div class="line">Sx[1][0] = one;  Sx[1][1] = zero;</div><div class="line"></div><div class="line">Sy[0][0] = zero; Sy[0][1] = -i;</div><div class="line">Sy[1][0] = i;    Sy[1][1] = zero;</div><div class="line"></div><div class="line">Sz[0][0] = one;  Sz[0][1] = zero;</div><div class="line">Sz[1][0] = zero; Sz[1][1] = -one;</div><div class="line"></div><div class="line"><a class="code" href="structAComplexMatrix.html">AComplexMatrix</a> comm(2, 2, buffer[3]);</div><div class="line"><a class="code" href="structAComplexMatrix.html">AComplexMatrix</a> tmp(2, 2, buffer[4]);</div><div class="line"></div><div class="line">commutator2x2(comm, Sx, Sx);   <span class="comment">// comm = [Sx, Sx]</span></div><div class="line">tmp.fill(<a class="code" href="structAComplex.html#a749ac35b9452523ceba7862d03c8fcca">AComplex::Zero</a>());    <span class="comment">// tmp  = 0</span></div><div class="line"><span class="keywordflow">if</span> (comm == tmp)</div><div class="line">    printf(<span class="stringliteral">&quot;[Sx, Sx] =  0\n&quot;</span>);</div><div class="line"></div><div class="line">commutator2x2(comm, Sy, Sy);   <span class="comment">// comm = [Sy, Sy]</span></div><div class="line"><span class="keywordflow">if</span> (comm == tmp)</div><div class="line">    printf(<span class="stringliteral">&quot;[Sy, Sy] =  0\n&quot;</span>);</div><div class="line"></div><div class="line">commutator2x2(comm, Sz, Sz);   <span class="comment">// comm = [Sz, Sz]</span></div><div class="line"><span class="keywordflow">if</span> (comm == tmp)</div><div class="line">    printf(<span class="stringliteral">&quot;[Sz, Sz] =  0\n&quot;</span>);</div><div class="line"></div><div class="line">commutator2x2(comm, Sx, Sy);   <span class="comment">// comm = [Sx, Sy]</span></div><div class="line">tmp.mul(Sz, two * i);          <span class="comment">// tmp  = 2i * Sz</span></div><div class="line"><span class="keywordflow">if</span> (comm == tmp)</div><div class="line">    printf(<span class="stringliteral">&quot;[Sx, Sy] =  2i * Sz\n&quot;</span>);</div><div class="line"></div><div class="line">commutator2x2(comm, Sx, Sz);    <span class="comment">// comm = [Sx, Sz]</span></div><div class="line">tmp.mul(Sy, -two * i);          <span class="comment">// tmp  = -2i * Sy</span></div><div class="line"><span class="keywordflow">if</span> (comm == tmp)</div><div class="line">    printf(<span class="stringliteral">&quot;[Sx, Sz] = -2i * Sy\n&quot;</span>);</div><div class="line"></div><div class="line">commutator2x2(comm, Sy, Sz);    <span class="comment">// comm = [Sy, Sz]</span></div><div class="line">tmp.mul(Sx, two * i);           <span class="comment">// tmp  = 2i * Sx</span></div><div class="line"><span class="keywordflow">if</span> (comm == tmp)</div><div class="line">    printf(<span class="stringliteral">&quot;[Sy, Sz] =  2i * Sx\n&quot;</span>);</div></div><!-- fragment --><p>Copyright 2018 Knowles Electronics, LLC. All rights reserved. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 14 2018 12:15:43 for Audience Vector Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
